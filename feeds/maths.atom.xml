<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>J. W. Kennington - Maths</title><link href="/" rel="alternate"></link><link href="/feeds/maths.atom.xml" rel="self"></link><id>/</id><updated>2019-04-15T00:00:00-05:00</updated><entry><title>Tensor Product for Programmers</title><link href="/blog/tensor-product-for-programmers/" rel="alternate"></link><published>2019-04-15T00:00:00-05:00</published><updated>2019-04-15T00:00:00-05:00</updated><author><name>J. W. Kennington</name></author><id>tag:None,2019-04-15:/blog/tensor-product-for-programmers/</id><summary type="html">&lt;p&gt;The introduction to tensor products and tensor algebras is often riddled with rigor, in which a mathematician would delight but a programmer would despair. I find myself in the intersection of these camps and while I appreciate notation, a simpler introduction is possible using functional programming concepts. &lt;/p&gt;
&lt;p&gt;Tensors are defined …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The introduction to tensor products and tensor algebras is often riddled with rigor, in which a mathematician would delight but a programmer would despair. I find myself in the intersection of these camps and while I appreciate notation, a simpler introduction is possible using functional programming concepts. &lt;/p&gt;
&lt;p&gt;Tensors are defined and introduced in two equivalent ways. The first way, called the "expansion coefficient" (or array) style of introducing tensors relies on many indices and iterates over the n dimensions of some array (n-dimensional generalization of a matrix) &lt;a href='#wikipediaTensorMultidimensionalArrays2019' id='ref-wikipediaTensorMultidimensionalArrays2019-1'&gt;Wikipedia (2019)&lt;/a&gt;. I have found this approach to be overly cluttered; missing the forest for the trees. Instead, I prefer the second way of defining tensors, namely as "multilinear maps" &lt;a href='#romanAdvancedLinearAlgebra2007' id='ref-romanAdvancedLinearAlgebra2007-1'&gt;Roman (2007)&lt;/a&gt; &lt;a href='#jeevanjeeIntroductionTensorsGroup2015' id='ref-jeevanjeeIntroductionTensorsGroup2015-1'&gt;Jeevanjee (2015)&lt;/a&gt;. This technique focuses on functions and interfaces, as opposed to components, and will be the chosen method of explaining below. &lt;/p&gt;
&lt;p&gt;Before we begin, a brief note about preferences between the "coefficient" and "multilinear" approaches. The latter way has found greater resonance with mathematicians, while programmers often find the former more comforting. I believe this is caused by an over-reliance on data structures as atomic units of understanding. True, it is natural as a developer to ask "but what &lt;em&gt;is&lt;/em&gt; the object"; however, using more functional-programming style of thought, the multilinear map approach is actually simpler! No need to keep track of various coefficients on various axes of some imaginary n-dimensional array (leave that to &lt;code&gt;numpy&lt;/code&gt;). In the below, I outline a functional-programming style analogy for tensors, and the tensor product. Thought the below snippets are in python, some details are left to the imagination (i.e. this code is not a script).&lt;/p&gt;
&lt;h3&gt;Setting the Stage&lt;/h3&gt;
&lt;p&gt;Before we get to define tensors, we need to briefly define a few building blocks. First, there is a field &lt;span class="math"&gt;\(C\)&lt;/span&gt;, commonly the reals &lt;span class="math"&gt;\(\mathbb{R}\)&lt;/span&gt;, occasionally the complex numbers &lt;span class="math"&gt;\(\mathbb{C}\)&lt;/span&gt;. Members of &lt;span class="math"&gt;\(C\)&lt;/span&gt; are called &lt;em&gt;scalars&lt;/em&gt; and are represented in the code by the type &lt;code&gt;scalar&lt;/code&gt;. Second, there are vector spaces &lt;span class="math"&gt;\(V\)&lt;/span&gt; over this field, with the usual properties of closure under addition and scalar multiplication. Elements of &lt;span class="math"&gt;\(V\)&lt;/span&gt; are of type &lt;code&gt;vector&lt;/code&gt;. Note, I am not specifying a vector as a tuple of scalars - though that is a valid vector space, there are others based on non-tuple like entities, like the vector space of square-integrable functions! The last piece of machinery is the dual space &lt;span class="math"&gt;\(V^*\)&lt;/span&gt;. If you're not familiar with the dual space, it is essentially the set of all linear functions that take 1 vector and spit out a scalar (specifically &lt;span class="math"&gt;\(V^* = \{f: V\rightarrow C\}\)&lt;/span&gt; where &lt;span class="math"&gt;\(f\)&lt;/span&gt; is linear). Elements of &lt;span class="math"&gt;\(V^*\)&lt;/span&gt; are of type &lt;code&gt;dual&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;Some dual vectors&lt;/h4&gt;
&lt;p&gt;Recall that dual vectors are functions that take a vector and return a scalar. Let &lt;span class="math"&gt;\(f, g \in V^*\)&lt;/span&gt;. In code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;scalar&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;scalar&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Tensor Product&lt;/h4&gt;
&lt;p&gt;Now let's define the tensor product of &lt;span class="math"&gt;\(f\)&lt;/span&gt; and &lt;span class="math"&gt;\(g\)&lt;/span&gt; as &lt;span class="math"&gt;\(h = f \otimes g\)&lt;/span&gt;. What this amounts to, is combining the functional interface into a new, single tensor (function), that curries to the functions it was made from! Specifically:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;scalar&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In some sense, the tensor (or outer) product is like a concatenation operation, that joins functions together, using the superset of arguments, and passing those arguments back to the original functions returning a scalar! This definition is easy!&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%&amp;#64;#$&amp;#64;#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;&lt;hr&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;p id='jeevanjeeIntroductionTensorsGroup2015'&gt;Nadir Jeevanjee.
&lt;em&gt;An Introduction to Tensors and Group Theory for Physicists&lt;/em&gt;.
&lt;span class="bibtex-protected"&gt;Springer Science+Business Media&lt;/span&gt;, New York, NY, 2015.
ISBN 978-3-319-14793-2. &lt;a class="cite-backref" href="#ref-jeevanjeeIntroductionTensorsGroup2015-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;p id='romanAdvancedLinearAlgebra2007'&gt;Steven Roman.
&lt;em&gt;Advanced Linear Algebra&lt;/em&gt;.
Number&amp;nbsp;135 in Graduate Texts in Mathematics.
&lt;span class="bibtex-protected"&gt;Springer&lt;/span&gt;, New York, 3rd ed edition, 2007.
ISBN 978-0-387-72828-5. &lt;a class="cite-backref" href="#ref-romanAdvancedLinearAlgebra2007-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;p id='wikipediaTensorMultidimensionalArrays2019'&gt;Wikipedia.
Tensor, as multidimensional arrays.
&lt;em&gt;Wikipedia&lt;/em&gt;, April 2019. &lt;a class="cite-backref" href="#ref-wikipediaTensorMultidimensionalArrays2019-1" title="Jump back to reference 1"&gt;↩&lt;/a&gt;&lt;/p&gt;
</content><category term="maths"></category><category term="tensors"></category></entry></feed>